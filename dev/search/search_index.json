{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#spacelidar","title":"SpaceLiDAR","text":"<p>A Julia toolbox for ICESat, ICESat-2 and GEDI data. Quickly search, download and load filtered point data with relevant attributes from the <code>.h5</code> granules of each data product. For an overview with code examples, see the FOSS4G Pluto notebook here.</p> <p>If you use SpaceLiDAR in your research, please consider citing it.</p> <p></p> <p></p>"},{"location":"#supported-data-products","title":"Supported data products","text":"<p>Currently supports the following data products:</p> mission data product User Guide (UG) Algorithm Theoretical Basis Document (ATBD) ICESat GLAH06 v34 UG ATBD ICESat GLAH14 v34 UG ATBD ICESat-2 ATL03 v6 UG ATBD ICESat-2 ATL06 v5 UG ATBD ICESat-2 ATL08 v6 UG ATBD ICESat-2 ATL12 v5 UG ATBD GEDI L2A v2 UG ATBD <p></p> <p></p>"},{"location":"#documentation","title":"Documentation","text":"<p>This documentation is set up using the Divio documentation system and thus split into Tutorials, Guides, Topics and References.</p> <p></p> <p></p>"},{"location":"#publications","title":"Publications","text":"<p>The code produced for the following paper was the beginning of this package:</p> <p>Vernimmen, Ronald, Aljosja Hooijer, and Maarten Pronk. 2020. \u2018New ICESat-2 Satellite LiDAR Data Allow First Global Lowland DTM Suitable for Accurate Coastal Flood Risk Assessment\u2019. Remote Sensing 12 (17): 2827. https://doi.org/10/gg9dg6.</p> <p>The DTM produced using ICESat-2 ATL08 data was in turn used for:</p> <p>Hooijer, A., and R. Vernimmen. 2021. \u2018Global LiDAR Land Elevation Data Reveal Greatest Sea-Level Rise Vulnerability in the Tropics\u2019. Nature Communications 12 (1): 3592. https://doi.org/10/gkzf49.</p>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#unreleased","title":"Unreleased","text":"<ul> <li>Working on generic retrieval of parameters as a Table from a granule, instead of the hardcoded choices made now for each product. Would result in methods like <code>points(granule, [vara, varb])</code>.</li> </ul>"},{"location":"changelog/#new-features","title":"New features","text":"<ul> <li>New types <code>Table</code> and <code>PartitionedTable</code>, which support the Tables.jl interface. This prevents allocating code like <code>reduce(vcat, DataFrame.(points(granule)))</code> to get a DataFrame. You can now just call <code>DataFrame(table)</code>.</li> <li>Reduced allocations in retrieving point data.</li> <li>Introduced <code>before</code> and <code>after</code> keywords in <code>search</code>, to search by date(ranges).</li> </ul>"},{"location":"changelog/#fixed","title":"Fixed","text":"<ul> <li>Empty (filtered) granules could result in <code>Vector{BitVector}</code> columns, which have been changed to <code>Vector{Bool}</code>.</li> </ul>"},{"location":"changelog/#breaking","title":"Breaking","text":"<ul> <li><code>points</code> now return either a <code>Table</code> or a <code>PartitionedTable</code> instead of <code>NamedTuple</code> or <code>Vector{NamedTuple}</code>. The old behaviour can be regained by calling <code>parent</code> on these tables.</li> <li>Removed <code>number_of_returns</code> and <code>return_number</code> from ICESat-2 ATL08 canopy output.</li> </ul>"},{"location":"changelog/#deprecated","title":"Deprecated","text":"<ul> <li>Renamed <code>granule_from_file</code> to <code>granule</code></li> <li>Renamed <code>granules_from_file</code> to <code>granules</code></li> <li>Renamed <code>write_granule_urls!</code> to <code>write_urls</code></li> </ul>"},{"location":"changelog/#changed","title":"Changed","text":"<ul> <li>Most of the search functionality has been moved out to the more generic EarthData.jl</li> <li>Updated ICESat-2 from version 5 to version 6</li> </ul>"},{"location":"changelog/#v030","title":"v0.3.0","text":"<ul> <li>GeoInterface, Extents support</li> <li>Bounding box using Extent subsetting on all <code>points</code> functions</li> <li><code>find</code> renamed to <code>search</code></li> <li><code>search</code> now takes the <code>product</code> as a <code>Symbol</code> and accepts a <code>s3::Bool</code> parameter.</li> <li>Stricter checking of arguments in <code>search</code></li> <li>MultiPolygon extents of granules are now returned in the <code>polygons</code> field in granules from <code>search</code>.</li> <li>Removed <code>bbox</code> field on granules.</li> <li><code>download(granule)</code> now works on AWS S3 urls</li> <li><code>donwload(granule)</code> now creates temporary files and renames after successful download</li> <li>ICESat-2 ATL08 v5 <code>points</code> function now supports 20 m resolution by passing <code>highres::Bool</code> parameter.</li> </ul>"},{"location":"changelog/#v022","title":"v0.2.2","text":"<ul> <li>Fixed ICESat-2 download (please remove <code>n5eil01u.ecs.nsidc.org</code> from your <code>.netrc</code> file)</li> <li>Linked to Zenodo for DOI citations</li> </ul>"},{"location":"changelog/#v021","title":"v0.2.1","text":"<ul> <li>Unified <code>bounds</code> of granules</li> <li>Fixed <code>getcoord</code> for <code>Point</code> and added <code>Point(x, y, z)</code> constructor</li> <li>Updated utils to make use of DataFrames with correct column names</li> </ul>"},{"location":"changelog/#v020","title":"v0.2.0","text":"<p>Warning</p> <p>This is a breaking release</p> <ul> <li>Many of the column names have changed to be more descriptive.</li> <li>Documentation and docstring improvements.</li> <li>Tables support, you can now do <code>DataFrame(granule)</code>, without having to call <code>points(granule)</code>.</li> <li>Memory use improvements, by using SentinelArray of FillArray under the hood.</li> <li>Dropped S3, GeoArrays and LAS/LAZ support.</li> <li>Added GeoInterface support for lines/points and dropped GeoDataFrames</li> <li>Expanded test coverage.</li> </ul> <p></p> <p></p>"},{"location":"changelog/#v016","title":"v0.1.6","text":"<ul> <li>Support for ICESat GLAH06 by alex-s-gardner </li> </ul>"},{"location":"changelog/#v015","title":"v0.1.5","text":"<ul> <li>Support for ICESat-2 ATL06</li> <li>Update search to use v5 for ICESat-2 by default</li> </ul>"},{"location":"changelog/#v014","title":"v0.1.4","text":"<ul> <li>Compatibility fixes</li> </ul>"},{"location":"changelog/#v013","title":"v0.1.3","text":"<ul> <li>Added interpolation for GeoArrays</li> <li>Added FOSS4G notebook</li> </ul>"},{"location":"guides/downloads/","title":"Downloading","text":""},{"location":"guides/downloads/#downloading","title":"Downloading","text":"<p>As shown in Tutorial: Search for data, it is easy to find data. Downloading the data might be harder though, especially when downloading a large amount of granules or even mirroring a complete DAAC. Indeed, the Julia <code>download!</code> won't work in parallel, nor will it resume downloads or show its progress. In such cases it's useful to export a list of granules to a text file and use an external download tool:</p> <pre><code>granules = find(:ICESat2, \"ATL08\")\nSpaceLiDAR.write_urls(\"atl08_world.txt\", granules)\n</code></pre> <p>In my case, I use aria2c. Note that downloading from the granule urls require a EarthData login, normally setup in an .netrc file (also see <code>netrc!</code>).</p> <pre><code>aria2c -c -i atl08_world.txt\n</code></pre> <p>Once finished, one can again <code>instantiate</code> the list of granules with the folder to which all files have been downloaded.</p>"},{"location":"guides/tracks/","title":"Track filtering","text":""},{"location":"guides/tracks/#track-filtering","title":"Track filtering","text":"<p>Coming soon</p>"},{"location":"reference/api/","title":"Index","text":""},{"location":"reference/api/#api-reference","title":"API reference","text":"<ul> <li><code>SpaceLiDAR.GEDI_Granule</code></li> <li><code>SpaceLiDAR.ICESat2_Granule</code></li> <li><code>SpaceLiDAR.ICESat_Granule</code></li> <li><code>Base.Filesystem.rm</code></li> <li><code>Base.convert</code></li> <li><code>SpaceLiDAR.angle!</code></li> <li><code>SpaceLiDAR.bounds</code></li> <li><code>SpaceLiDAR.bounds</code></li> <li><code>SpaceLiDAR.classify</code></li> <li><code>SpaceLiDAR.download</code></li> <li><code>SpaceLiDAR.download</code></li> <li><code>SpaceLiDAR.download!</code></li> <li><code>SpaceLiDAR.download!</code></li> <li><code>SpaceLiDAR.info</code></li> <li><code>SpaceLiDAR.info</code></li> <li><code>SpaceLiDAR.info</code></li> <li><code>SpaceLiDAR.instantiate</code></li> <li><code>SpaceLiDAR.isvalid</code></li> <li><code>SpaceLiDAR.netrc!</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.points</code></li> <li><code>SpaceLiDAR.search</code></li> <li><code>SpaceLiDAR.shift</code></li> <li><code>SpaceLiDAR.sync</code></li> <li><code>SpaceLiDAR.to_egm2008!</code></li> </ul>"},{"location":"reference/data/","title":"Data","text":""},{"location":"reference/data/#data","title":"Data","text":""},{"location":"reference/data/#icesat","title":"ICESat","text":"<p># <code>SpaceLiDAR.points</code> \u2014 Method.</p> <pre><code>points(g::ICESat_Granule{:GLAH06}, step=1, bbox::Union{Nothing,Extent,NamedTuple} = nothing)\n</code></pre> <p>Retrieve the points for a given ICESat GLAH06 (Land Ice) granule as a list of namedtuples The names of the tuples are based on the following fields:</p> Variable Original Field Description Units <code>longitude</code> <code>Data_40HZ/Geolocation/d_lon</code> Longitude of segment center, WGS84, East=+ decimal degrees <code>latitude</code> <code>Data_40HZ/Geolocation/d_lat</code> Latitude of segment center, WGS84, North=+ decimal degrees <code>height</code> <code>Data_40HZ/Elevation_Surfaces/d_elev</code> + <code>Data_40HZ/Elevation_Corrections/d_satElevCorr</code> m above WGS84 ellipsoid <code>datetime</code> <code>Data_40HZ/DS_UTCTime_40</code> Precise time of aquisiton date-time <code>quality</code> <sup>1</sup> <code>Data_40HZ/Quality/elev_use_flg</code> &amp; <code>Data_40HZ/Quality/sigma_att_flg</code> = 0 &amp; <code>Data_40HZ/Waveform/i_numPk</code> = 1 &amp; <code>Data_40HZ/Elevation_Corrections/d_satElevCorr</code> &lt; 3 1 = high quality <code>height_reference</code> <code>land_ice_segments/dem/dem_h</code> Height of the (best available) DEM height above WGS84 <p>You can get the output in a <code>DataFrame</code> with <code>DataFrame(points(g))</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.points</code> \u2014 Method.</p> <pre><code>points(g::ICESat_Granule{:GLAH14}, step=1, bbox::Union{Nothing,Extent,NamedTuple} = nothing)\n</code></pre> <p>Retrieve the points for a given ICESat GLAH14 (Land Surface) granule as a list of namedtuples The names of the tuples are based on the following fields:</p> Variable Original Field (in <code>Data_40HZ</code>) Description Units <code>longitude</code> <code>/Geolocation/d_lon</code> Longitude of segment center, WGS84, East=+ decimal degrees <code>latitude</code> <code>Geolocation/d_lat</code> Latitude of segment center, WGS84, North=+ decimal degrees <code>height</code> <code>Elevation_Surfaces/d_elev</code> + <code>Elevation_Corrections/d_satElevCorr</code> m above WGS84 ellipsoid <code>datetime</code> <code>DS_UTCTime_40</code> Precise time of aquisiton date-time <code>quality</code> <sup>1</sup> <code>Quality/elev_use_flg</code> &amp; <code>Quality/sigma_att_flg</code> = 0 &amp; <code>Waveform/i_numPk</code> = 1 &amp; <code>Elevation_Corrections/d_satElevCorr</code> &lt; 3 1=high quality <code>clouds</code> <code>Elevation_Flags/elv_cloud_flg</code> Cloud contamination - <code>height_reference</code> <code>Geophysical/d_DEM_elv</code> Height of the (best available) DEM height above WGS84 <code>gain</code> <code>Waveform/i_gval_rcv</code> Gain value used for received pulse. - <code>reflectivity</code> <code>Reflectivity/d_reflctUC</code> Reflectivity, not corrected - <code>attitude</code> <code>Quality/sigma_att_flg</code> Attitude quality indicator 0=good; 50=warning; 100=bad; <code>saturation</code> <code>Quality/sat_corr_flg</code> Saturation Correction Flag 0=not_saturated; <p>You can get the output in a <code>DataFrame</code> with <code>DataFrame(points(g))</code>.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/data/#icesat-2","title":"ICESat-2","text":"<p># <code>SpaceLiDAR.classify</code> \u2014 Function.</p> <pre><code>classify(granule::ICESat2_Granule{:ATL03}, atl08::Union{ICESat2_Granule{:ATL08},Nothing} = nothing, tracks = icesat2_tracks)\n</code></pre> <p>Like <code>points(::ICESat2_Granule{:ATL03})</code> but with the classification from the ATL08 dataset. If an ATL08 granule is not provided, we try to find it based on the ATL03 name using <code>convert</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.points</code> \u2014 Method.</p> <pre><code>points(g::ICESat2_Granule{:ATL03}, tracks=icesat2_tracks; step=1, bbox::Union{Nothing,Extent,NamedTuple} = nothing)\n</code></pre> <p>Retrieve the points for a given ICESat-2 ATL03 (Global Geolocated Photon Data) granule as a list of namedtuples, one for each beam. The names of the tuples are based on the following fields:</p> Column Field Description Units <code>longitude</code> <code>heights/lon_ph</code> Longitude of photon, WGS84, East=+ decimal degrees <code>latitude</code> <code>heights/lat_ph</code> Latitude of photon, WGS84, North=+ decimal degrees <code>height</code> <code>heights/h_ph</code> Photon WGS84 Height m above the WGS 84 ellipsoid <code>quality</code> <code>heights/quality_ph</code> Indicates the quality of the associated photon 0 = nominal <code>uncertainty</code> <code>geolocation/sigma_h</code> Estimated height uncertainty m <code>datetime</code> <code>heights/delta_time</code> + <code>ancillary_data/atlas_sdp_gps_epoch</code> + <code>gps_offset</code> date-time <code>confidence</code> <code>heights/signal_conf_ph</code> Photon Signal Confidence 2=low; 3=med; 4=high <code>segment</code> <code>geolocation/segment_id</code> Along-track segment ID number - <code>track</code> <code>gt1l</code> - <code>gt3r</code> groups - - <code>strong_beam</code> <code>-</code> \"strong\" (true) or \"weak\" (false) laser power - <code>sun_angle</code> <code>geolocation/solar_elevation</code> Sun angle \u00b0 above horizon <code>detector_id</code> <code>atlas_spot_number attribute</code> - - <code>height_reference</code> <code>heights/dem/dem_h</code> Height of the (best available) DEM m above the WGS 84 ellipsoid <p>You can combine the output in a <code>DataFrame</code> with <code>reduce(vcat, DataFrame.(points(g)))</code> if you want to change the default arguments or <code>DataFrame(g)</code> with the default options.</p> <p>source</p> <p># <code>SpaceLiDAR.points</code> \u2014 Method.</p> <pre><code>points(g::ICESat2_Granule{:ATL06}, tracks=icesat2_tracks, step=1, bbox::Union{Nothing,Extent,NamedTuple} = nothing)\n</code></pre> <p>Retrieve the points for a given ICESat-2 ATL06 (Land Ice) granule as a list of namedtuples, one for each beam. The names of the tuples are based on the following fields:</p> Column Field Description Units <code>longitude</code> <code>land_ice_segments/longitude</code> Longitude of segment center, WGS84, East=+ decimal degrees <code>latitude</code> <code>land_ice_segments/latitude</code> Latitude of segment center, WGS84, North=+ decimal degrees <code>height</code> <code>land_ice_segments/h_li</code> Standard land-ice segment height m above the WGS 84 ellipsoid <code>height_error</code> \u221a(<code>land_ice_segments/sigma_geo_h</code>\u00b2 + Total vertical geolocation error m above the WGS 84 ellipsoid <code>land_ice_segments/h_li_sigma</code>\u00b2) <code>datetime</code> <code>land_ice_segments/delta_time</code> + <code>ancillary_data/atlas_sdp_gps_epoch</code> + <code>gps_offset</code> date-time <code>quality</code> <code>land_ice_segments/atl06_quality_summary</code> Boolean flag indicating the best-quality subset 1 = high quality <code>track</code> <code>gt1l</code> - <code>gt3r</code> groups - - <code>strong_beam</code> <code>-</code> \"strong\" (true) or \"weak\" (false) laser power - <code>detector_id</code> <code>atlas_spot_number attribute</code> - - <code>height_reference</code> <code>land_ice_segments/dem/dem_h</code> Height of the (best available) DEM - <p>You can combine the output in a <code>DataFrame</code> with <code>reduce(vcat, DataFrame.(points(g)))</code> if you want to change the default arguments or <code>DataFrame(g)</code> with the default options.</p> <p>source</p> <p># <code>SpaceLiDAR.points</code> \u2014 Method.</p> <pre><code>points(g::ICESat2_Granule{:ATL08}; tracks=icesat2_tracks, step=1, canopy=false, ground=true, bbox::Union{Nothing,Extent,NamedTuple} = nothing)\n</code></pre> <p>Retrieve the points for a given ICESat-2 ATL08 (Land and Vegetation Height) granule as a list of namedtuples, one for each beam. With the <code>tracks</code> keyword, you can specify which tracks to include. The default is to include all tracks. With the <code>step</code> keyword, you can choose to limit the number of points, the default is 1 (all points). With setting <code>ground</code> and or <code>canopy</code>, you can control to include ground and/or canopy points. Finally, with the <code>ground_field</code> and <code>canopy_field</code> settings, you can determine the source field. The default is <code>h_te_mean</code> for ground and <code>h_mean_canopy_abs</code> for canopy. With the introduction of v5, a 20m resolution is also available for estimation, which you can enable with <code>highres</code>. Note that filtering with a bounding box doesn't yet work when <code>highres</code> is true.</p> <p>The names of the tuples are based on the following fields:</p> Column Field Description Units <code>longitude</code> <code>land_segments/longitude</code> Longitude of segment center, WGS84, East=+ decimal degrees <code>latitude</code> <code>land_segments/latitude</code> Latitude of segment center, WGS84, North=+ decimal degrees <code>height</code> <code>land_segments/terrain/h_te_mean</code> Standard land-ice segment height m above the WGS 84 ellipsoid <code>height_error</code> <code>land_segments/terrain/h_te_uncertainty</code> Total vertical geolocation error m <code>datetime</code> <code>land_segments/delta_time</code> + <code>ancillary_data/atlas_sdp_gps_epoch</code> + <code>gps_offset</code> date-time <code>quality</code> <code>land_segments/terrain_flg</code> Boolean flag indicating the best-quality subset 1 = high quality <code>phr</code> <code>land_segments/ph_removal_flag</code> More than 50% of photons removed - <code>sensitivity</code> <code>land_segments/snr</code> The signal to noise ratio - <code>scattered</code> <code>land_segments/msw_flag</code> Multiple Scattering warning flag -1=unknown; 0=none <code>saturated</code> <code>land_segments/sat_flag</code> Saturation detected - <code>clouds</code> <code>land_segments/layer_flag</code> Clouds or blowing snow are likely present - <code>track</code> <code>gt1l</code> - <code>gt3r</code> groups - - <code>strong_beam</code> <code>-</code> \"strong\" (true) or \"weak\" (false) laser power - <code>classification</code> <code>-</code> \"ground\", \"high_canopy\" - <code>height_reference</code> <code>land_segments/dem_h</code> Height of the (best available) DEM m above the WGS 84 ellipsoid <code>detector_id</code> <code>atlas_spot_number attribute</code> - - <p>You can combine the output in a <code>DataFrame</code> with <code>reduce(vcat, DataFrame.(points(g)))</code> if you want to change the default arguments or just <code>DataFrame(g)</code> with the default options.</p> <p>source</p> <p># <code>SpaceLiDAR.points</code> \u2014 Function.</p> <pre><code>points(g::ICESat2_Granule{:ATL12}, tracks=icesat2_tracks)\n</code></pre> <p>Retrieve the points for a given ICESat-2 ATL12 (Ocean Surface Height) granule as a list of namedtuples, one for each beam. The names of the tuples are based on the following fields:</p> Column Field Description Units <code>longitude</code> <code>ssh_segments/longitude</code> Longitude of segment center, WGS84, East=+ decimal degrees <code>latitude</code> <code>ssh_segments/latitude</code> Latitude of segment center, WGS84, North=+ decimal degrees <code>height</code> <code>ssh_segments/heights/h</code> Standard land-ice segment height m above the WGS 84 ellipsoid <code>datetime</code> <code>ssh_segments/delta_time</code> + <code>ancillary_data/atlas_sdp_gps_epoch</code> + <code>gps_offset</code> date-time <code>track</code> <code>gt1l</code> - <code>gt3r</code> groups - - <code>strong_beam</code> <code>-</code> \"strong\" (true) or \"weak\" (false) laser power - <code>detector_id</code> <code>atlas_spot_number attribute</code> - - <p>You can combine the output in a <code>DataFrame</code> with <code>reduce(vcat, DataFrame.(points(g)))</code> if you want to change the default arguments or <code>DataFrame(g)</code> with the default options.</p> <p>source</p> <p></p> <p></p>"},{"location":"reference/data/#gedi","title":"GEDI","text":"<p># <code>SpaceLiDAR.bounds</code> \u2014 Method.</p> <pre><code>bounds(granule::GEDI_Granule)\n</code></pre> <p>Return the bounds of the GEDI granule.</p> <p>Warning</p> <p>This opens the .h5 file to read all tracks, so it is very slow.</p> <p>source</p> <ol> <li> <p>Smith, B., Fricker, H. A., Gardner, A. S., Medley, B., Nilsson, J., Paolo, F. S., ... &amp; Zwally, H. J. (2020). Pervasive ice sheet mass loss reflects competing ocean and atmosphere processes. Science, 368(6496), 1239-1242.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"reference/granules/","title":"Granules","text":""},{"location":"reference/granules/#granules","title":"Granules","text":"<p># <code>Base.Filesystem.rm</code> \u2014 Method.</p> <pre><code>rm(granule::Granule)\n</code></pre> <p>Remove the file associated with <code>granule</code> from the local filesystem.</p> <p>source</p> <p># <code>SpaceLiDAR.download</code> \u2014 Function.</p> <pre><code>download(granule::Granule, folder=\".\")\n</code></pre> <p>Download the file associated with <code>granule</code> to the <code>folder</code>, from an http(s) location if it doesn't already exists locally. Returns a new granule. See <code>download!</code> for a mutating version.</p> <p>Will require credentials (netrc) which can be set with <code>netrc!</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.download</code> \u2014 Function.</p> <pre><code>download(granules::Vector{&lt;:Granule}, folder=\".\")\n</code></pre> <p>Like <code>download</code>, but for a vector of <code>granules</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.download!</code> \u2014 Function.</p> <pre><code>download!(granule::Granule, folder=\".\")\n</code></pre> <p>Download the file associated with <code>granule</code> to the <code>folder</code>, from an http(s) location if it doesn't already exists locally.</p> <p>Will require credentials (netrc) which can be set with <code>netrc!</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.download!</code> \u2014 Function.</p> <pre><code>download!(granules::Vector{&lt;:Granule}, folder=\".\")\n</code></pre> <p>Like <code>download!</code>, but for a vector of <code>granules</code>. Will make use of aria2c (parallel).</p> <p>source</p> <p># <code>SpaceLiDAR.sync</code> \u2014 Function.</p> <pre><code>sync(folder::AbstractString, all::Bool=false; kwargs...)\nsync(folders::AbstractVector{&lt;:AbstractString}, all::Bool=false; kwargs...)\nsync(product::Symbol, folder::AbstractString, all::Bool=false; kwargs...)\nsync(product::Symbol, folders::AbstractVector{&lt;:AbstractString}, all::Bool=false; kwargs...)\n</code></pre> <p>Syncronize an existing archive of local granules in <code>folder(s)</code> with the latest granules available. Specifically, this will run <code>search</code> and <code>download</code> for any granules not yet present in folder(s), to the first folder in the list.</p> <p>Warning</p> <p>Using sync could result in downloading significant (TB+) amounts of data.</p> <p>Assumes all folders contain granules of the same product. If not, pass the product as Symbol: <code>sync(::Symbol, folders, all)</code> instead.</p> <p>When <code>all</code> is false (the default), sync will search only for granules past the date of the latest granule found in <code>folders</code>. If true, it will search for all granules. Note that ICESat granules are not timestamped, so sync will try to download all ICESat granules not yet present, regardless of this setting.</p> <p>Any <code>kwargs...</code> are passed to the <code>search</code> function. This enables sync to only download granules within a certain extent, for example.</p> <p>source</p> <p># <code>SpaceLiDAR.ICESat_Granule</code> \u2014 Type.</p> <pre><code>ICESat_Granule{product} &lt;: Granule\n</code></pre> <p>A granule of the ICESat product <code>product</code>. Normally created automatically from either <code>find</code>, <code>granule_from_file</code> or <code>granules_from_folder</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.info</code> \u2014 Method.</p> <pre><code>info(g::ICESat_Granule)\n</code></pre> <p>Derive info based on the filename. The name is built up as follows: ATL03[yyyymmdd][hhmmss][ttttccss][vvvrr].h5. See section 1.2.5 in the user guide.</p> <p>source</p> <p># <code>SpaceLiDAR.ICESat2_Granule</code> \u2014 Type.</p> <pre><code>ICESat2_Granule{product} &lt;: Granule\n</code></pre> <p>A granule of the ICESat-2 product <code>product</code>. Normally created automatically from either <code>find</code>, <code>granule_from_file</code> or <code>granules_from_folder</code>.</p> <p>source</p> <p># <code>Base.convert</code> \u2014 Method.</p> <pre><code>Base.convert(product::Symbol, g::ICESat2_Granule{T})\n</code></pre> <p>Converts the granule <code>g</code> to the product <code>product</code>, by guessing the correct name.</p> <p>source</p> <p># <code>SpaceLiDAR.bounds</code> \u2014 Method.</p> <pre><code>bounds(granule::ICESat2_Granule)\n</code></pre> <p>Retrieves the bounding box of the granule.</p> <p>Warning</p> <p>This opens the .h5 file, so it is slow.</p> <p>Example</p> <pre><code>julia&gt; bounds(g)\ng = ICESat2_Granule()\n</code></pre> <p>source</p> <p># <code>SpaceLiDAR.info</code> \u2014 Method.</p> <pre><code>info(g::ICESat2_Granule)\n</code></pre> <p>Derive info based on the filename. The name is built up as follows: <code>ATL03_[yyyymmdd][hhmmss]_[ttttccss]_[vvv_rr].h5</code>. See section 1.2.5 in the user guide.</p> <p>source</p> <p># <code>SpaceLiDAR.GEDI_Granule</code> \u2014 Type.</p> <pre><code>GEDI_Granule{product} &lt;: Granule\n</code></pre> <p>A granule of the GEDI product <code>product</code>. Normally created automatically from either <code>find</code>, <code>granule_from_file</code> or <code>granules_from_folder</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.info</code> \u2014 Method.</p> <pre><code>info(g::GEDI_Granule)\n</code></pre> <p>Derive info based on the filename. This is built up as follows: <code>GEDI02_A_2019110014613_O01991_T04905_02_001_01.h5</code> or in case of v\"2\": <code>GEDI02_A_2019242104318_O04046_01_T02343_02_003_02_V002.h5</code>. See section 2.4 in the user guide.</p> <p>source</p>"},{"location":"reference/search/","title":"Search","text":""},{"location":"reference/search/#search","title":"Search","text":"<p># <code>SpaceLiDAR.search</code> \u2014 Function.</p> <pre><code>search(mission::Mission, bbox::Extent)\nsearch(:GEDI02_A, \"002\")  # searches *all* GEDI v2 granules\n</code></pre> <p>Search granules for a given mission and bounding box.</p> <p>source</p>"},{"location":"reference/utilities/","title":"Utilities","text":""},{"location":"reference/utilities/#utilities","title":"Utilities","text":"<p># <code>SpaceLiDAR.angle!</code> \u2014 Method.</p> <pre><code>angle!(table)\n</code></pre> <p>Sets the <code>angle</code> column in <code>table</code> as returned from <code>points</code>. See <code>angle</code> for details.</p> <p>source</p> <p># <code>SpaceLiDAR.shift</code> \u2014 Method.</p> <pre><code>shift(longitude, latitude, angle, distance)\n</code></pre> <p>Shift <code>longitude</code> and <code>latitude</code> with <code>distance</code> in [m] in direction <code>angle</code>, where North is 0\u00b0. Returns a tuple of the shifted coordinates: <code>(longitude, latitude)</code>. Useful for offsetting SpaceLiDAR points to the left or right of the track, in combination with <code>angle</code>.</p> <p>source</p> <p># <code>SpaceLiDAR.to_egm2008!</code> \u2014 Method.</p> <pre><code>to_egm2008!(table)\n</code></pre> <p>Converts ellipsoid heights to geoid heights using the EGM2008 geoid model. Assumes a table as generated from <code>points</code> with columns <code>:latitude</code>, <code>:longitude</code>, and <code>:height</code>. Will overwrite the <code>:height</code> column with the geoid height.</p> <p>source</p> <p>&lt;a id='SpaceLiDAR.instantiate-Union{Tuple{T}, Tuple{Vector{T}, AbstractString}} where T&lt;:SpaceLiDAR.Granule' href='#SpaceLiDAR.instantiate-Union{Tuple{T}, Tuple{Vector{T}, AbstractString}} where T&lt;:SpaceLiDAR.Granule'&gt;# <code>SpaceLiDAR.instantiate</code> \u2014 Method.</p> <pre><code>instantiate(granules::Vector{::Granule}, folder::AbstractString)\n</code></pre> <p>For a given list of <code>granules</code> from <code>find</code>, match the granules to the local files and return a new list of granules with the local filepaths if they exist.</p> <p>source</p> <p># <code>SpaceLiDAR.isvalid</code> \u2014 Method.</p> <pre><code>isvalid(g::Granule)\n</code></pre> <p>Checks if a granule is has a valid, local and non-corrupt .h5 file. Can be combined with <code>rm(::Granule)</code> to remove invalid granules.</p> <p>source</p> <p># <code>SpaceLiDAR.netrc!</code> \u2014 Method.</p> <pre><code>netrc!(username, password)\n</code></pre> <p>Writes/updates a .netrc file for ICESat-2 and GEDI downloads. A .netrc is a plaintext file containing your username and password for NASA EarthData and DAACs, and can be automatically used by Julia using <code>Downloads</code> and tools like <code>wget</code>, <code>curl</code> among others.</p> <p>source</p>"},{"location":"topics/GEDI/","title":"GEDI","text":""},{"location":"topics/GEDI/#gedi","title":"GEDI","text":"<p>GEDI-launched in 2018-is attached to the ISS and is to investigate global ecosystems<sup>1</sup>.</p> <p>We currently only support the L2A product (at version 2).</p> <p>See their website.</p> <ol> <li> <p>Dubayah, Ralph, James Bryan Blair, Scott Goetz, Lola Fatoyinbo, Matthew Hansen, Sean Healey, Michelle Hofton, et al. 2020. \u201cThe Global Ecosystem Dynamics Investigation: High-Resolution Laser Ranging of the Earth\u2019s Forests and Topography.\u201d Science of Remote Sensing 1 (June): 100002. https://doi.org/10/ggjxx8.\u00a0\u21a9</p> </li> </ol>"},{"location":"topics/ICESat-2/","title":"ICESat-2","text":""},{"location":"topics/ICESat-2/#icesat-2","title":"ICESat-2","text":"<p>ICESat-2 is in a polar orbit to investigate ice sheets<sup>1</sup> using its Advanced Topographic Laser Altimeter System (ATLAS).</p> <p>We currently support the ATL03, ATL06, ATL08 and ATL12 data products (at version 5).</p> <p>See their website.</p> <ol> <li> <p>Markus, Thorsten, Tom Neumann, Anthony Martino, Waleed Abdalati, Kelly Brunt, Beata Csatho, Sinead Farrell, et al. 2017. \u201cThe Ice, Cloud, and Land Elevation Satellite-2 (ICESat-2): Science Requirements, Concept, and Implementation.\u201d Remote Sensing of Environment 190 (March): 260\u201373. https://doi.org/10/gg3f7c.\u00a0\u21a9</p> </li> </ol>"},{"location":"topics/ICESat/","title":"ICESat","text":""},{"location":"topics/ICESat/#icesat","title":"ICESat","text":"<p>The Ice, Cloud, and land Elevation Satellite (1) (ICESat) was the first earth-based LiDAR satellite<sup>1</sup>, launched in 2003, with the primary goal of ice sheet monitoring. It had an elevation accuracy of several cm<sup>1</sup> and was operational for five years.</p> <p>We currently support the GLAH06 (Land Ice) and GLA14 (Land Surface) data products (at version 34).</p> <p>See their website.</p> <ol> <li> <p>Schutz, B. E., H. J. Zwally, C. A. Shuman, D. Hancock, and J. P. DiMarzio. 2005. \u201cOverview of the ICESat Mission.\u201d Geophysical Research Letters 32 (21). https://doi.org/10/bzbspg.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"tutorial/installation/","title":"Installation","text":""},{"location":"tutorial/installation/#installation","title":"Installation","text":"<p>Use the Julia built-in package manager:</p> <pre><code>] add SpaceLiDAR\n</code></pre>"},{"location":"tutorial/usage/","title":"Usage","text":""},{"location":"tutorial/usage/#usage","title":"Usage","text":""},{"location":"tutorial/usage/#search-for-data","title":"Search for data","text":"<pre><code>using SpaceLiDAR\n# Find all ATL08 granules\ngranules = search(:ICESat2, :ATL08)\n\n# Find only ATL03 granules in a part of Vietnam\nvietnam = Extent(X = (102., 107.0), Y = (8.0, 12.0))\ngranules = search(:ICESat2, :ATL08; extent=vietnam, version=6)\n\n# Find GEDI granules in the same way\ngranules = search(:GEDI, :GEDI02_A)\n\n# A granule is pretty simple\ngranule = granules[1]\ngranule.id  # filename\ngranule.url  # download url\ngranule.info  # derived information from id\n\n# Downloading granules requires a setup .netrc with an NASA EarthData account\n# we provide a helper function, that creates/updates a ~/.netrc or ~/_netrc\nSpaceLiDAR.netrc!(username, password)  # replace with your credentials\n\n# Afterward you can download the dataset\nfn = SpaceLiDAR.download!(granule)\n\n# You can also load a granule from disk\ngranule = granule(fn)\n\n# Or from a folder\nlocal_granules = granules(folder)\n\n# Instantiate search results locally (useful for GEDI location indexing)\nlocal_granules = instantiate(granules, folder)\n</code></pre>"},{"location":"tutorial/usage/#derive-points","title":"Derive points","text":"<pre><code>using DataFrames\nfn = \"GEDI02_A_2019242104318_O04046_01_T02343_02_003_02_V002.h5\"\ng = SpaceLiDAR.granule(fn)\ndf = DataFrame(g)\n149680\u00d715 DataFrame\n    Row \u2502 longitude  latitude  height    height_error  datetime                 intensity  sensitivity  surface  quality  nmo \u22ef\n        \u2502 Float64    Float64   Float32   Float32       DateTime                 Float32    Float32      Bool     Bool     UIn \u22ef\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n      1 \u2502   153.855  -47.2772  -13.3536      0.307976  2019-08-30T10:48:21.047   393.969   -0.0671094      true    false      \u22ef\n      2 \u2502   153.855  -47.2769  -11.2522      0.307978  2019-08-30T10:48:21.055   797.26     0.533529       true     true\n      3 \u2502   153.856  -47.2767  -13.775       0.307981  2019-08-30T10:48:21.063  1010.39     0.695938       true     true\n      4 \u2502   153.857  -47.2765  -11.729       0.307983  2019-08-30T10:48:21.071   852.614    0.544849       true     true\n      5 \u2502   153.857  -47.2763  -13.2443      0.307985  2019-08-30T10:48:21.080   980.66     0.620767       true     true      \u22ef\n      6 \u2502   153.858  -47.2761  -12.1813      0.307987  2019-08-30T10:48:21.088   937.441    0.620531       true     true\n      7 \u2502   153.859  -47.2758  -11.9011      0.30799   2019-08-30T10:48:21.096  1235.02     0.73815        true     true\n      8 \u2502   153.859  -47.2756  -12.3796      0.307992  2019-08-30T10:48:21.104   854.127    0.545655       true     true\n</code></pre>"},{"location":"tutorial/usage/#derive-linestrings","title":"Derive linestrings","text":"<pre><code>using DataFrames\nfn = \"ATL03_20181110072251_06520101_003_01.h5\"\ng = SpaceLiDAR.granule(fn)\ntlines = DataFrame(SpaceLiDAR.lines(g, step=10000))\nTable with 4 columns and 6 rows:\n     geom                       sun_angle  track        datetime\n   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n 1 \u2502 wkbLineString25D geometry  38.3864    gt1l_weak    2018-11-10T07:28:01.688\n 2 \u2502 wkbLineString25D geometry  38.375     gt1r_strong  2018-11-10T07:28:02.266\n 3 \u2502 wkbLineString25D geometry  38.2487    gt2l_weak    2018-11-10T07:28:04.474\n 4 \u2502 wkbLineString25D geometry  38.1424    gt2r_strong  2018-11-10T07:28:07.374\n 5 \u2502 wkbLineString25D geometry  38.2016    gt3l_weak    2018-11-10T07:28:05.051\n 6 \u2502 wkbLineString25D geometry  38.1611    gt3r_strong  2018-11-10T07:28:06.344\nSpaceLiDAR.GDF.write(\"lines.gpkg\", tlines)\n</code></pre>"}]}